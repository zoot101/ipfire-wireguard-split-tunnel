#!/usr/bin/env bash

#######################################
# IPFire Wireguard VPN Split Tunnel Script
#######################################
# Github Page: https://github.com/zoot101/ipfire-wireguard-split-tunnel
#######################################

# Version 
version="0.3.1"

#######################################
# Parameters
#######################################
# Script Config File
config_file="/etc/wireguard-vpn-tunnel/wireguard-vpn-tunnel.conf"

# VPN Adapter Naming & Routing Table
table_name="wg-vpn"
table_ID="202"
policy_priority="1000"
excluded_priority="900"

# IPv4 Regex to validate IPs
ipv4_regex='^(([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))\.){3}([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))$'

# Use set -e to exit if any command exits in error
set -e

#######################################
# Include Necessary Functions
#######################################
shopt -s nullglob

. /etc/sysconfig/rc
. ${rc_functions}

#######################################
# Main Function
#######################################
main() {

  # Determine Input Arguments
  parse_arguments "$@"
  
  # Check for root
  check_for_root

  # Check for Required Commands
  check_for_required_commands

  # Read the config file
  read_config_file
  
  # Print Greeting
  print_greeting
 
  # Main Case Statement 
  # 1. Start the Tunnel
  case "${action}" in
  start)
  
    # Print Standard Message Regardless if --debug is not used
    if [ "${debug_mode}" == "no" ]; then boot_mesg "Starting WireGuard VPN Tunnel..."; fi

    # Check if the Tunnel Exists - If so exit
    check_if_tunnel_already_exists
  
    # Set a trap to clean up if this block fails or is interrupted.
    trap stop_tunnel EXIT INT TERM
  
    # Start the Tunnel
    start_tunnel
  
    # If we reached here, bringing up the tunnel was successful, disable
    # the trap for a clean exit
    trap - EXIT INT TERM
    exit 0
    ;;
  
  # 2. Stop the Tunnel
  stop)
  
    # Print Standard Message Regardless if --debug is not used
    if [ "${debug_mode}" == "no" ]; then boot_mesg "Stopping WireGuard VPN Tunnel..."; fi
  
    # Check if the Tunnel does not exist - If so exit
    check_if_tunnel_does_not_exist
  
    # Stop the Tunnel
    stop_tunnel
    exit 0
    ;;
  
  # 3. Show the Status (Debug Mode Only)
  status)
  
    # Show the Status
    if [ "${debug_mode}" == "yes" ]; then show_status; fi
    exit 0
    ;;

  # 4. Reload
  reload)
    $0 stop
    sleep 3
    $0 start
    exit 0
    ;;

  # 5. Reload
  restart)
    $0 stop
    sleep 3
    $0 start
    exit 0
    ;;

  # 6. Print Help
  -h|--help)
    print_help
    ;;

  # 7. All Other Arguments - Print Help & Exit
  *)
    echo "ERROR: Unsupported Action ${action}"
    echo ""
    print_help
    ;;

  esac
  exit 0
}

#######################################
# Functions
#######################################

# Parse Input Arguments to Script
parse_arguments() {

  # Valid Usage:
  # wireguard-vpn-tunnel [ --debug | --help ] [ ACTION ]

  # Unset below variables
  action=
  debug_mode=
  custom_config_file=

  # Loop through each of the input arguments
  while (( ${#} )); do
    case "${1}" in

      # Determine Action
      start)
        action="start"
      ;;
      stop)
        action="stop"
      ;;
      reload)
        action="reload"
      ;;
      restart)
        action="restart"
      ;;
      status)
        action="status"
      ;;

      # Determine Options
      -h|--help)
        print_help
      ;;
      -d|--debug)
        debug_mode="yes"
      ;;
      -c|--config)
        shift 1
        if [ ! -f "${1}" ]; then
          echo "ERROR: Specified Config File ${1} does not exist - Exiting"
          exit 1
        else
          custom_config_file="${1}"
        fi
      ;;

      # Unsupported Input
      *)
        echo "ERROR: Unsupported Input ${1}"
        echo ""
        print_help
      ;;
    esac
    shift 1
  done

  # Check for Undefined actions
  if [ -z "${action}" ]; then
    echo "ERROR: No Action given - See below:"
    echo ""
    print_help
  fi

  # Check for Debug Mode
  if [ -z "${debug_mode}" ]; then
    debug_mode="no"
  fi
}

# Print Message (if Debug Mode is active)
log() {
  if [ "${debug_mode}" == "yes" ]; then
    echo "$@"
  fi
}

# Exit with Error
error() {
  if [ "${debug_mode}" == "yes" ]; then
    echo "ERROR: ""$@"
  fi
  exit 1
}

# Check for Root
check_for_root() {
  if [ $(id -u) -ne 0 ]; then
    error "Script should be run as root - Exiting"
  fi
}

# Check For a Number
is_number() {
  local number_regex='^[0-9]+$'
  if ! [[ "$1" =~ $number_regex ]]; then
    return 1
  else
    return 0
  fi
}

# Function to valid correct syntax of IP entries in Config File
validate_ip_entry() {
  local input=("$@")
  local N_ips=${#input[@]}

  # Check each of the IPs - The IP & the Network Prefix
  for i in $(seq 0 1 $((N_ips-1))); do
    local ip=$( echo "${input[$i]}" | awk -F "/" '{print $1}' )
    local prefix=$( echo "${input[$i]}" | awk -F "/" '{print $2}' )

    # Check the prefix is valid if defined
    if [ -n "${prefix}" ]; then
      if ! is_number "${prefix}"; then
        error "${input[$i]} has an invalid prefix - Exiting"
      elif [ ${prefix} -lt 0 ] || [ ${prefix} -gt 32 ]; then
        error "${input[$i]} has an invalid prefix - Exiting"
      fi
    fi

    # Check the IP is valid
    if ! echo "${ip}" | grep -qEo "${ipv4_regex}"; then
      error "${input[$i]} is an invalid IP - Exiting"
    fi
  done
}

# Sanity Check Required Commands are present
check_for_required_commands() {
  if ! which sed &>"/dev/null"; then error "sed command not found in \$PATH - Exiting"; fi
  if ! which ip &>"/dev/null"; then error "ip command not found in \$PATH - Exiting"; fi
  if ! which iptables &>"/dev/null"; then error "iptables command not found in \$PATH - Exiting"; fi
  if ! which grep &>"/dev/null"; then error "grep command not found in \$PATH - Exiting"; fi
  if ! which awk &>"/dev/null"; then error "awk command not found in \$PATH - Exiting"; fi
  if ! which wg &>"/dev/null"; then error "wg command not found in \$PATH - Exiting"; fi
}

# Check if Interface exists (Green, Blue, Orange)
check_interface_exists() {
  if ! ip a | grep -qw "${1}"; then
    error "Interface ${1} does not exist - Exiting"
  fi
}

# Print Greeting (If Debug Mode is active)
print_greeting() {
  log ""
  log "#######################################"
  log "# Wireguard VPN Tunnel Version: ${version}"
  log "#######################################"
  if [ -n "${green_network}" ]; then log " * Green Network:" "${green_network}"; fi
  if [ -n "${blue_network}" ]; then log " * Blue Network:" "${blue_network}"; fi
  if [ -n "${orange_network}" ]; then log " * Orange Network:" "${orange_network}"; fi
  if [ -n "${roadwarrior_network}" ]; then log " * Roadwarrior Network:" "${roadwarrior_network}"; fi
  log " * Wireguard Tunnel Interface:" "${wg_vpn_interface}"
  log " * Wireguard Tunnel Interface Local IP:" "${wg_local_ip}"
  log " * Wireguard Tunnel Endpoint IP & Port:" "${wg_endpoint}"
  log " * Number of IP Entries for Tunnel:" $N_tunnel_ips
  for i in $(seq 0 1 $((N_tunnel_ips-1)) ); do
    log "    - ${tunnel_ips[$i]}"
  done
  if [ -n "${excluded_ips}" ]; then
    log " * Number of IP Entries to Exclude from Tunnel:" $N_excluded_ips
    for i in $(seq 0 1 $((N_excluded_ips-1)) ); do
      log "    - ${excluded_ips[$i]}"
    done
  else
    log " * Number of IP Entries to Exclude from Tunnel: NONE"
  fi
  if [ "${block_tunnel_dns}" == "yes" ]; then
    log " * Restrict Tunnel DNS: Yes"
    log " * Number of Local DNS Servers:" $N_local_dns_servers
    for i in $(seq 0 1 $((N_local_dns_servers-1)) ); do
      log "    - ${local_dns_servers[$i]}"
    done
  else
    log " * Restrict Tunnel DNS: No"
  fi
  if [ "${route_firewall_dns_into_tunnel}" == "yes" ]; then
    log " * Route Firewall DNS into Tunnel: Yes"
  else
    log " * Route Firewall DNS into Tunnel: No"
  fi
  log "#######################################"
  log ""
}

# Read Config File
read_config_file() {

  # Zero All Config File Variables
  wg_vpn_interface=
  roadwarrior_network=
  roadwarrior_iface=
  green_iface=
  green_network=
  blue_iface=
  blue_network=
  orange_iface=
  orange_network=
  tunnel_ips=
  excluded_ips=
  wg_config_file=
  wg_private_key=
  wg_public_key=
  wg_endpoint=
  wg_local_ip=
  block_tunnel_dns=
  local_dns_servers=
  route_firewall_dns_into_tunnel=

  # Read the Configuration File - Default Location or what was specifed with the
  # -c|--config option
  if [ -f "${custom_config_file}" ]; then
    log "INFO: Main Config File     : ${custom_config_file}"
    . "${custom_config_file}"
  elif [ -f "${config_file}" ]; then
    log "INFO: Main Config File     : ${config_file}"
    . "${config_file}"
  else
    exit 1
  fi

  # Check for all required parameters, if any do not exist exit with an Error
  # Wireguard Interface Name & Associated Config File from VPN Provider
  if [ -z "${wg_vpn_interface}" ]; then
    error "No wg_vpn_interface defined in config file - Exiting"
  fi
  if [ "${wg_vpn_interface}" == "wg0" ]; then
    error "wg_vpn_interface should not be wg0 to avoid conflicts - Exiting"
  fi
  if [ ! -f "${wg_config_file}" ]; then
    error "Wireguard Config File ${wg_config_file} does not exist - Exiting"
  else
    log "INFO: Wireguard Config File: ${wg_config_file}"
  fi

  # Check that at least some IPs for the Tunnel are Defined
  if [ -z "${tunnel_ips}" ]; then
    error "No tunnel_ips defined in config file - Exiting"
  fi

  # Every IPFire Configuration has a Green network - Exit if the interface & Network are not defined
  if [ -z "${green_iface}" ]; then error "No green_iface defined in config file"; fi
  if [ -z "${green_network}" ]; then error "No green_network defined in config File - Exiting"; fi

  # Blue (Optional)
  if [ -z "${blue_iface}" ] && [ -n "${blue_network}" ]; then
    error "For the Blue Network, a blue_iface AND blue_network should be defined in the config file - Exiting"
  elif [ -n "${blue_iface}" ] && [ -z "${blue_network}" ]; then
    error "For the Blue Network, a blue_iface AND blue_network should be defined in the config file - Exiting"
  fi

  # Orange (Optional)
  if [ -z "${orange_iface}" ] && [ -n "${orange_network}" ]; then
    error "For the Orange Network, a orange_iface AND orange_network should be defined in the config file - Exiting"
  elif [ -n "${orange_iface}" ] && [ -z "${orange_network}" ]; then
    error "For the Orange Network, a orange_iface AND orange_network should be defined in the config file - Exiting"
  fi

  # Roadwarrior (Wireguard/OpenVPN - Optional)
  if [ -z "${roadwarrior_iface}" ] && [ -n "${roadwarrior_network}" ]; then
    error "If using a Wireguard/OpenVPN roadwarrior network, a roadwarrior_iface AND roadwarrior_network should be defined in the config file - Exiting"
  elif [ -n "${roadwarrior_iface}" ] && [ -z "${roadwarrior_network}" ]; then
    error "If using a Wireguard/OpenVPN roadwarrior network, a roadwarrior_iface AND roadwarrior_network should be defined in the config file - Exiting"
  fi

  # Check if the User wishes to only allow certain IPs to access DNS over the tunnel
  if [ -n "${block_tunnel_dns}" ] && [ -z "${local_dns_servers}" ]; then
    error "If restricting DNS through the tunnel to certain IPs, both the block_tunnel_dns and local_dns_servers should be defined in the config file - Exiting"
  elif [ -z "${block_tunnel_dns}" ] && [ -n "${local_dns_servers}" ]; then
    error "If restricting DNS through the tunnel to certain IPs, both the block_tunnel_dns and local_dns_servers should be defined in the config file - Exiting"
  fi 

  # Check if the block_tunnel_dns is either yes or no if defined
  if [ -n "${block_tunnel_dns}" ]; then
    if [ "${block_tunnel_dns}" != "yes" ] && [ "${block_tunnel_dns}" != "no" ]; then
      error "block_tunnel_dns parameter should be either yes or no if defined - Exiting"
    fi
  else
    block_tunnel_dns="no"
  fi

  # Get Number of Local DNS Servers defined if restricting DNS through the tunnel
  if [ "${block_tunnel_dns}" == "yes" ]; then
    N_local_dns_servers=${#local_dns_servers[@]}
  else
    N_local_dns_servers=0
  fi

  # Check if the User wants to Route the Firewall's DNS into the Tunnel
  if [ -n "${route_firewall_dns_into_tunnel}" ]; then
    if [ "${route_firewall_dns_into_tunnel}" != "yes" ] && [ "${route_firewall_dns_into_tunnel}" != "no" ]; then
      error "route_firewall_dns_into_tunnel parameter should be either yes or no if defined - Exiting"
    fi
  else
    route_firewall_dns_into_tunnel="no"
  fi

  # Get Number of IP Addresses to exclude from being routed over the tunnel 
  if [ -n "${excluded_ips}" ]; then
    N_excluded_ips=${#excluded_ips[@]}
  else
    N_excluded_ips=0
  fi

  # Check the Interfaces given in the Config File actually exist to avoid accidents
  if [ -n "${green_iface}" ]; then check_interface_exists "${green_iface}"; fi
  if [ -n "${blue_iface}" ]; then check_interface_exists "${blue_iface}"; fi
  if [ -n "${orange_iface}" ]; then check_interface_exists "${orange_iface}"; fi
  if [ -n "${roadwarrior_iface}" ]; then check_interface_exists "${roadwarrior_iface}"; fi

  # Validate All IP Entries are of Correct Syntax in the Config File
  if [ -n "${green_network}" ]; then validate_ip_entry "${green_network}"; fi
  if [ -n "${blue_network}" ]; then validate_ip_entry "${blue_network}"; fi
  if [ -n "${orange_network}" ]; then validate_ip_entry "${orange_network}"; fi
  if [ -n "${roadwarrior_network}" ]; then validate_ip_entry "${roadwarrior_network}"; fi
  if [ -n "${tunnel_ips[0]}" ]; then validate_ip_entry "${tunnel_ips[@]}"; fi
  if [ -n "${excluded_ips[0]}" ]; then validate_ip_entry "${excluded_ips[@]}"; fi
  if [ -n "${local_dns_servers[0]}" ]; then validate_ip_entry "${local_dns_servers[@]}"; fi

  # Get the Number of IP Address Entries to be routed over the tunnel
  N_tunnel_ips=${#tunnel_ips[@]}

  # Get the Required Parameters from the Wireguard VPN Providers Config File
  # Important parameters are the Private & Public Keys, the local IP and the Endpoint
  # The use of awk is to only use the ipv4 configuration if the provider supplies both
  # since IPFire v2.2.X does not support ipv6
  wg_private_key=$(grep "PrivateKey" "${wg_config_file}" | sed "s/ //g;s/^PrivateKey=//")
  wg_public_key=$(grep "PublicKey" "${wg_config_file}" | sed "s/ //g;s/^PublicKey=//")
  wg_endpoint=$(grep "Endpoint" "${wg_config_file}" | sed "s/ //g;s/^Endpoint=//")
  wg_local_ip=$(grep "Address" "${wg_config_file}" | sed "s/ //g;s/^Address=//" | awk -F "," '{print $1}')

  # Exit if any of the above parameters are not defined
  if [ -z "${wg_private_key}" ]; then error "No wg_private_key defined in config file - Exiting"; fi
  if [ -z "${wg_public_key}" ]; then error "No wg_public_key defined in config file - Exiting"; fi
  if [ -z "${wg_endpoint}" ]; then error "No wg_endpoint defined in config file - Exiting"; fi
  if [ -z "${wg_local_ip}" ]; then error "No wg_local_ip defined in config file - Exiting"; fi

  # Sanity Check to Validate the Endpoint Address, Port & Local Address
  validate_ip_entry "${wg_local_ip}"
  validate_ip_entry $( echo "${wg_endpoint}" | awk -F ":" '{print $1}')
  if ! is_number $(echo "${wg_endpoint}" | awk -F ":" '{print $2}'); then
    error "wg_endpoint: ${wg_endpoint} Port is invalid - Exiting"
  fi

  # Finally, Sanity check the CUSTOMPOSTROUTING, CUSTOMFORWARD, CUSTOMINPUT & CUSTOMOUTPUT
  # Chains exist
  if ! iptables --wait -S CUSTOMFORWARD &>"/dev/null"; then
    error "CUSTOMFORWARD Firewall Chain Not Found - Exiting"
  fi
  if ! iptables --wait -t nat -S CUSTOMPOSTROUTING &>"/dev/null"; then
    error "CUSTOMPOSTROUTING Firewall Chain Not Found - Exiting"
  fi
  if ! iptables --wait -S CUSTOMOUTPUT &>"/dev/null"; then
    error "CUSTOMOUTPUT Firewall Chain Not Found - Exiting"
  fi
  if ! iptables --wait -S CUSTOMINPUT &>"/dev/null"; then
    error "CUSTOMINPUT Firewall Chain Not Found - Exiting"
  fi
}

# Bring up the Wireguard Interface using the VPN Providers Config File
create_wireguard_interface() {

  log " [START] Bringing up VPN tunnel: ${wg_vpn_interface}..."

  # 1. Create the WireGuard interface
  ip link add "${wg_vpn_interface}" type wireguard

  # 2. Assign the local IP address to the interface.
  ip addr add "${wg_local_ip}" dev "${wg_vpn_interface}"

  log " [START] Activate wireguard VPN profile on ${wg_vpn_interface}..."

  # 3. Apply the necessary parameters from the wireguard config file
  wg set "${wg_vpn_interface}" private-key <( echo "${wg_private_key}") \
                               peer "${wg_public_key}" \
                               endpoint "${wg_endpoint}" \
                               allowed-ips "0.0.0.0/0"

  # 4. Bring the interface UP.
  ip link set "${wg_vpn_interface}" up
}

# Remove the Wireguard Interface
remove_wireguard_interface() {
  log " [STOP] Tearing down ${wg_vpn_interface}..."
  ip link del "${wg_vpn_interface}" 2>/dev/null || true
}

# Create Custom Routing Table
create_custom_routing_table() {

  log " [START] Creating Custom Routing Table..."

  # 1. Register the custom routing table if it doesn't already exist.
  if ! grep -q "${table_name}" "/etc/iproute2/rt_tables"; then
    echo "${table_ID} ${table_name}" >> "/etc/iproute2/rt_tables"
  fi

  # 2. Populate the custom routing table with a complete set of routes.
  #    depending on whether a green, blue or orange network are defined
  ip route flush table "${table_name}" 2>/dev/null || true
  if [ -n "${green_network}" ]; then
    ip route add "${green_network}" dev "${green_iface}" table "${table_name}"
  fi
  if [ -n "${blue_network}" ]; then
    ip route add "${blue_network}" dev "${blue_iface}" table "${table_name}"
  fi
  if [ -n "${orange_network}" ]; then
    ip route add "${orange_network}" dev "${orange_iface}" table "${table_name}"
  fi
  if [ -n "${roadwarrior_network}" ]; then
    ip route add "${roadwarrior_network}" dev "${roadwarrior_iface}" table "${table_name}"
  fi
  ip route add default dev "${wg_vpn_interface}" table "${table_name}"
}

# Setup Firewall Rules with Custom NAT & Forwarding Rules
setup_firewall_rules() {

  log " [START] Adding NAT & Forwarding rules..."

  # Add a Masquerade rule for all traffic exiting via new VPN tunnel interface
  iptables --wait -t nat -A CUSTOMPOSTROUTING -o "${wg_vpn_interface}" -j MASQUERADE

  # 2. Add Individual Firewall Rules to the CUSTOMFORWARD Chain for each of the IPs defined
  #    in the config file to allow them to be routed over the tunnel
  for i in $(seq 0 1 $((N_tunnel_ips-1)) ); do

    # Calculate Positions
    position1=$((2*i+1))
    position2=$((2*i+2))

    # Add Firewall Rules - Accept outbound connection & inbound if established
    iptables --wait -I CUSTOMFORWARD $position1 -s "${tunnel_ips[$i]}" -o "${wg_vpn_interface}" -j ACCEPT
    iptables --wait -I CUSTOMFORWARD $position2 -d "${tunnel_ips[$i]}" -i "${wg_vpn_interface}" -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  done
}

# Remove Firewall Custom NAT & Forwarding Rules
remove_firewall_rules() {

  # Remove the Masquerade Rule
  iptables --wait -t nat -D CUSTOMPOSTROUTING -o "${wg_vpn_interface}" -j MASQUERADE 2>/dev/null || true

  # Remove each of the Rules Added Above
  for i in $(seq 0 1 $((N_tunnel_ips-1)) ); do
    iptables --wait -D CUSTOMFORWARD -s "${tunnel_ips[$i]}" -o "${wg_vpn_interface}" -j ACCEPT || true
    iptables --wait -D CUSTOMFORWARD -d "${tunnel_ips[$i]}" -i "${wg_vpn_interface}" -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT || true
  done
}

# Activate Main Policy Based Routing Rule(s)
activate_policy_based_routing() {

  log " [START] Activating Policy Based Routing..."
  for i in $(seq 0 1 $((N_tunnel_ips-1)) ); do
    ip rule add from "${tunnel_ips[$i]}" table "${table_name}" priority $((policy_priority+i))
  done
}

# Remove the Main Policy Based Routing Rule(s)
remove_policy_based_routing() {

  log " [STOP] Removing Policy Based Routing..."
  for i in $(seq 0 1 $((N_tunnel_ips-1)) ); do
    ip rule del from "${tunnel_ips[$i]}" table "${table_name}" priority $((policy_priority+i)) || true
  done
}

# Check Tunnel already exists - If so, exit & do nothing (For start_tunnel)
check_if_tunnel_already_exists() {
  if ip link show "${wg_vpn_interface}" >/dev/null 2>&1; then
    log " [WARNING] Tunnel ${wg_vpn_interface} already appears to be active. No action taken."
    exit 0
  fi
}

# Check if the Tunnel does not exist - Exit if so (For stop_tunnel)
check_if_tunnel_does_not_exist() {
  if ! ip link show "${wg_vpn_interface}" >/dev/null 2>&1; then
    log " [WARNING] Tunnel ${wg_vpn_interface} does not exist. No action taken."
    exit 0
  fi
}

# Setup DNS Firewall Rules - Allow only certain IPs to send DNS requests down the Tunnel
setup_dns_firewall_rules() {

  # Block DNS Requests from Green, Blue & Orange Networks through the Tunnel by default
  if [ "${block_tunnel_dns}" == "yes" ]; then
    log " [START] Setting Up DNS Firewall Rules on VPN tunnel: ${wg_vpn_interface}..."

    if [ -n "${green_network}" ]; then
      iptables --wait -I CUSTOMFORWARD -o "${wg_vpn_interface}" -s "${green_network}" -m multiport -p tcp --dports 53,853 -j DROP
      iptables --wait -I CUSTOMFORWARD -o "${wg_vpn_interface}" -s "${green_network}" -m multiport -p udp --dports 53,853 -j DROP
    fi
    if [ -n "${blue_network}"  ]; then
      iptables --wait -I CUSTOMFORWARD -o "${wg_vpn_interface}" -s "${blue_network}" -m multiport -p tcp --dports 53,853 -j DROP
      iptables --wait -I CUSTOMFORWARD -o "${wg_vpn_interface}" -s "${blue_network}" -m multiport -p udp --dports 53,853 -j DROP
    fi
    if [ -n "${orange_network}" ]; then
      iptables --wait -I CUSTOMFORWARD -o "${wg_vpn_interface}" -s "${orange_network}" -m multiport -p tcp --dports 53,853 -j DROP
      iptables --wait -I CUSTOMFORWARD -o "${wg_vpn_interface}" -s "${orange_network}" -m multiport -p udp --dports 53,853 -j DROP
    fi
  fi

  # Allow each of the IP addresses of the Local DNS Servers through the tunnel if defined
  if [ -n "${local_dns_servers[0]}" ]; then
    for i in $(seq 0 1 $((N_local_dns_servers-1)) ); do
      iptables --wait -I CUSTOMFORWARD -o "${wg_vpn_interface}" -s "${local_dns_servers[$i]}" -m multiport -p tcp --dports 53,853 -j ACCEPT
      iptables --wait -I CUSTOMFORWARD -o "${wg_vpn_interface}" -s "${local_dns_servers[$i]}" -m multiport -p udp --dports 53,853 -j ACCEPT
    done
  fi
}

# Remove DNS Firewall Rules - Remove above DNS Firewall Rules
remove_dns_firewall_rules() {

  # Block DNS Requests from Green, Blue & Orange Networks through the Tunnel by default
  if [ "${block_tunnel_dns}" == "yes" ]; then
    log " [STOP] Removing DNS Firewall Rules on VPN tunnel: ${wg_vpn_interface}..."

    if [ -n "${green_network}" ]; then
      iptables --wait -D CUSTOMFORWARD -o "${wg_vpn_interface}" -s "${green_network}" -m multiport -p tcp --dports 53,853 -j DROP || true
      iptables --wait -D CUSTOMFORWARD -o "${wg_vpn_interface}" -s "${green_network}" -m multiport -p udp --dports 53,853 -j DROP || true
    fi
    if [ -n "${blue_network}"  ]; then
      iptables --wait -D CUSTOMFORWARD -o "${wg_vpn_interface}" -s "${blue_network}" -m multiport -p tcp --dports 53,853 -j DROP || true
      iptables --wait -D CUSTOMFORWARD -o "${wg_vpn_interface}" -s "${blue_network}" -m multiport -p udp --dports 53,853 -j DROP || true
    fi
    if [ -n "${orange_network}" ]; then
      iptables --wait -D CUSTOMFORWARD -o "${wg_vpn_interface}" -s "${orange_network}" -m multiport -p tcp --dports 53,853 -j DROP || true
      iptables --wait -D CUSTOMFORWARD -o "${wg_vpn_interface}" -s "${orange_network}" -m multiport -p udp --dports 53,853 -j DROP || true
    fi
  fi

  # Remove the rules for each of the IP addresses of the Local DNS Servers if defined
  if [ -n "${local_dns_servers[0]}" ]; then
    for i in $(seq 0 1 $((N_local_dns_servers-1)) ); do
      iptables --wait -D CUSTOMFORWARD -o "${wg_vpn_interface}" -s "${local_dns_servers[$i]}" -m multiport -p tcp --dports 53,853 -j ACCEPT || true
      iptables --wait -D CUSTOMFORWARD -o "${wg_vpn_interface}" -s "${local_dns_servers[$i]}" -m multiport -p udp --dports 53,853 -j ACCEPT || true
    done
  fi
}

# Add rules to exclude certain IPs from being routed over the tunnel
add_excluded_ips() {
  if [ $N_excluded_ips -gt 0 ]; then
    log " [START] Adding Policy Based Routing Rules to Exclude IPs..."
    for i in $(seq 0 1 $((N_excluded_ips-1)) ); do
      ip rule add from "${excluded_ips[$i]}" table main priority $((excluded_priority+i))
    done
  fi
}

# Remove the above rules
remove_excluded_ips() {
  if [ $N_excluded_ips -gt 0 ]; then
    log " [STOP] Removing Policy Based Routing Rules to Exclude IPs..."
    for i in $(seq 0 1 $((N_excluded_ips-1)) ); do
      ip rule delete from "${excluded_ips[$i]}" table main priority $((excluded_priority+i)) || true
    done
  fi
}

# Send the Firewall DNS into the Tunnel
send_firewall_dns_over_tunnel() {

  # Add Firewall Rules to allow the Firewall itself to send traffic over the tunnel,
  # and add a Policy Based rule to send everything to ports 53 or 853 over the tunnel
  if [ "${route_firewall_dns_into_tunnel}" == "yes" ]; then
    log " [START] Allowing the Firewall DNS into tunnel: ${wg_vpn_interface}..."
    iptables --wait -I CUSTOMOUTPUT -o "${wg_vpn_interface}" -m multiport -p tcp --dports 53,853 -j ACCEPT
    iptables --wait -I CUSTOMOUTPUT -o "${wg_vpn_interface}" -m multiport -p udp --dports 53,853 -j ACCEPT
    iptables --wait -I CUSTOMINPUT -i "${wg_vpn_interface}" -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
    ip rule add dport 53 table "${table_name}" priority $((policy_priority+200))
    ip rule add dport 853 table "${table_name}" priority $((policy_priority+201))
  fi
}

# Remove the Firewall DNS from the Tunnel
remove_firewall_dns_from_tunnel() {

  # Remove the Firewall Rules & Routing Rules added above
  if [ "${route_firewall_dns_into_tunnel}" == "yes" ]; then
    log " [STOP] Removing the Firewall DNS from going to the tunnel: ${wg_vpn_interface}..."
    iptables --wait -D CUSTOMOUTPUT -o "${wg_vpn_interface}" -m multiport -p tcp --dports 53,853 -j ACCEPT || true
    iptables --wait -D CUSTOMOUTPUT -o "${wg_vpn_interface}" -m multiport -p udp --dports 53,853 -j ACCEPT || true
    iptables --wait -D CUSTOMINPUT -i "${wg_vpn_interface}" -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT || true
    ip rule delete dport 53 table "${table_name}" priority $((policy_priority+200)) || true
    ip rule delete dport 853 table "${table_name}" priority $((policy_priority+201)) || true
  fi
}

# Print Help Function
print_help() {
  echo "Usage: ${0} [ OPTIONS ] { ACTION } "
  echo ""
  echo " ACTION (Required) can be one of the following:"
  echo ""
  echo "  start      : Start the VPN Tunnel - Does the Following:"
  echo "               * Bring up a new Wireguard Interface using the VPN Providers Config File"
  echo "               * Create a custom routing table"
  echo "               * Add the necessary firewall rules to allow routing over the Tunnel"
  echo "               * Setup firewall rules to block all DNS over the tunnel with the exception"
  echo "                 of dedicated DNS Servers (if enabled in config file)"
  echo "               * Activate Policy Based Routing Rules to activate the VPN Tunnel"
  echo "               * Add additional Policy Based Routing Rules to exclude certain IPs from"
  echo "                 being routed over the tunnel (if enabled in config file)"
  echo ""
  echo "  stop       : Stop the VPN Tunnel - Does the Following:"
  echo "               * Remove the Policy Based Routing rules"
  echo "               * Remove the main firewall rules created above"
  echo "               * Remove the Policy Based Routing rules to exclude certain IPs"
  echo "                 (if enabled in config file)"
  echo "               * Remove the Policy Based Routing rules to exclude certain IPs from"
  echo "                 being routed over the tunnel (if enabled in config file)"
  echo "               * Remove the firewall rules to block all DNS over the tunnel with the exception"
  echo "                 of dedicated DNS Servers (if enabled in config file)"
  echo "               * Remove the Wireguard Interface"
  echo ""
  echo "  status     : Display the Status of the Following (if --debug is used - see below:)"
  echo "               * Custom Routing Table"
  echo "               * Policy Based Routing Rules"
  echo "               * Custom Firewall Rules"
  echo "               * Wireguard Interface Status"
  echo ""
  echo "  reload     : Stop & Restart the VPN Tunnel"
  echo ""
  echo "  restart    : Stop & Restart the VPN Tunnel"
  echo ""
  echo " OPTIONS (Optional) can be the following:"
  echo ""
  echo "  -c|--config PATH-TO-CONFIG-FILE : Override default config file path (below)"
  echo ""
  echo "  -d|--debug : Print out detailed information about configuration and each of theabove steps"
  echo "               as by default the script has a quiet output"
  echo ""
  echo "  -h|--help  : Print this message"
  echo ""
  echo " CONFIG-FILE : Default: /etc/wireguard-vpn-tunnel/wireguard-vpn-tunnel.conf"
  echo ""
  exit 0
}

#######################################
# Main Functions
#######################################
# Start the VPN Tunnel
start_tunnel() {

  # 1. Create the Wireguard Interface
  create_wireguard_interface

  # 2. Create the Custom Routing Table
  create_custom_routing_table

  # 3. Configure Firewall with Custom NAT & Forwarwarding Rules
  setup_firewall_rules

  # 4. Set up the DNS Firewall rules if one is using
  setup_dns_firewall_rules

  # 5 - Activate the Policy Based Routing
  activate_policy_based_routing

  # 6. Add the policy rules to exclude certain IPs
  add_excluded_ips

  # 7. Route the Firewall DNS into the Tunnel (if enabled)
  send_firewall_dns_over_tunnel

  # 8. Flush route cache to ensure the new rules are applied immediately.
  ip route flush cache

  log " [START] VPN tunnel and policy routing are active."
}

# Stop the VPN Tunnel
stop_tunnel() {

  # 1. Remove the policy rule. This immediately stops routing traffic to the VPN table.
  remove_policy_based_routing

  # 2. Remove Firewall rules.
  remove_firewall_rules

  # 3. Add the policy rules to exclude certain IPs
  remove_excluded_ips

  # 4. Set up the DNS Firewall rules if one is using
  remove_dns_firewall_rules

  # 5. Remove the Firewall DNS from going over the tunnel (if enabled)
  remove_firewall_dns_from_tunnel

  # 6. Remove the interface. This is the cleanest way to stop everything.
  remove_wireguard_interface

  log " [STOP] VPN tunnel and all associated rules have been removed."
}

# Show the Status of the Tunnel
show_status() {

  log " [STATUS] VPN Configuration Status ==="
  log ""

  log " [STATUS] Routing table '${table_name}':"
  ip route list table ${table_name} 2>/dev/null || log " Table '${table_name}' not found or empty"
  log ""

  log " [STATUS] Policy routing rules:"
  ip rule show
  log ""

  log " [STATUS] CUSTOMFORWARD Rirewall Rules:"
  iptables --wait -L CUSTOMFORWARD -n -v 2>/dev/null || log " CUSTOMFORWARD chain not found"
  log ""

  log " [STATUS] CUSTOMPOSTROUTING NAT Rules:"
  iptables --wait -t nat -L CUSTOMPOSTROUTING -n -v 2>/dev/null || log " CUSTOMPOSTROUTING chain not found"
  log ""

  if [ "${route_firewall_dns_into_tunnel}" == "yes" ]; then
    log " [STATUS] CUSTOMOUTPUT Rirewall Rules:"
    iptables --wait -L CUSTOMOUTPUT -n -v 2>/dev/null || log " CUSTOMOUTPUT chain not found"
    log ""

    log " [STATUS] CUSTOMINPUT Rules:"
    iptables --wait -L CUSTOMINPUT -n -v 2>/dev/null || log " CUSTOMINPUT chain not found"
    log ""
  fi

  log " [STATUS] WireGuard VPN Interface Status:"
  if ip link show "${wg_vpn_interface}" >/dev/null 2>&1; then
    log " * WireGuard Configuration:"
    log ""
    wg show "${wg_vpn_interface}" 2>/dev/null || log " WireGuard config not available"
    log ""
    log " * Interface Addresses:"
    log ""
    ip addr show "${wg_vpn_interface}"
  else
    log " * WireGuard Interface ${wg_vpn_interface} not found"
  fi
  log ""
}

#######################################
# Main Function
#######################################
main "$@"

